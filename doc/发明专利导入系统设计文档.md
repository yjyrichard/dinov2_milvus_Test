# 发明专利导入与检索系统设计文档

## 一、系统概述

### 1.1 目标

构建一个发明专利（Utility Patent）的批量导入与语义检索系统：
- **数据来源**：`D:\data` 下的 `UTIL`（实用专利）和 `REISSUE`（再颁专利）目录
- **排除目录**：后缀为 `-SUPP` 的目录、`DESIGN` 目录（外观专利）
- **向量化模型**：`Qwen3-VL-Embedding` 部署在 `192.168.1.27`（GPU服务器）
- **检索方式**：用户输入产品名称 + 描述，检索相关发明专利

### 1.2 系统架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           前端 (Vue.js)                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  产品名称输入  │  产品描述输入  │  搜索按钮  │  结果展示           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                       后端 API (FastAPI)                                 │
│                       192.168.1.174 (当前机器)                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                   │
│  │ 搜索接口      │  │ 批量导入接口  │  │ 状态查询接口  │                   │
│  └──────────────┘  └──────────────┘  └──────────────┘                   │
└─────────────────────────────────────────────────────────────────────────┘
         │                    │                    │
         ▼                    ▼                    ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│ Milvus 向量数据库 │  │ MinIO 对象存储   │  │ Embedding 服务   │
│ 192.168.1.174   │  │ 192.168.1.174   │  │ 192.168.1.27    │
│ :31278          │  │ :9000           │  │ :8100           │
└─────────────────┘  └─────────────────┘  └─────────────────┘
                                                   │
                                                   ▼
                                          ┌─────────────────┐
                                          │ Qwen3-VL-Emb    │
                                          │ GPU 服务器       │
                                          └─────────────────┘
```

---

## 二、数据目录结构

### 2.1 目录扫描规则

```
D:\data\
├── I20251202\                    # 日期目录
│   ├── I20251202\                # 内层同名目录
│   │   ├── UTIL\                 # ✅ 发明专利（需处理）
│   │   │   ├── US20251234567A1\  # A1 申请公开
│   │   │   │   ├── US20251234567A1\
│   │   │   │   │   ├── US20251234567-20251202.XML
│   │   │   │   │   ├── US20251234567-20251202-D00001.TIF
│   │   │   │   │   └── ...
│   │   │   ├── US12345678B2\     # B2 授权专利
│   │   │   └── ...
│   │   ├── REISSUE\              # ✅ 再颁专利（需处理）
│   │   │   ├── USRE050588E1\
│   │   │   └── ...
│   │   ├── DESIGN\               # ❌ 外观专利（跳过）
│   │   └── UTIL-SUPP\            # ❌ 补充数据（跳过）
│   └── I20251202-SUPP\           # ❌ 补充数据（跳过）
└── ...
```

### 2.2 扫描逻辑

```python
def should_process_directory(dir_name: str) -> bool:
    """判断是否应该处理该目录"""
    # 排除后缀为 -SUPP 的目录
    if dir_name.endswith('-SUPP'):
        return False
    # 排除 DESIGN 目录
    if dir_name == 'DESIGN':
        return False
    return True

def scan_utility_patents(data_dir: str):
    """扫描发明专利目录"""
    for date_dir in Path(data_dir).iterdir():
        if not date_dir.is_dir() or date_dir.name.endswith('-SUPP'):
            continue

        inner_dir = date_dir / date_dir.name
        if not inner_dir.exists():
            continue

        # 处理 UTIL 目录
        util_dir = inner_dir / 'UTIL'
        if util_dir.exists():
            yield from scan_patent_directory(util_dir, 'UTIL')

        # 处理 REISSUE 目录
        reissue_dir = inner_dir / 'REISSUE'
        if reissue_dir.exists():
            yield from scan_patent_directory(reissue_dir, 'REISSUE')
```

---

## 三、Embedding 服务设计（192.168.1.27）

### 3.1 服务架构

在 GPU 服务器上部署独立的 Embedding HTTP 服务，提供文本向量化接口。

```
┌─────────────────────────────────────────────────────────────┐
│              Embedding Service (192.168.1.27:8100)           │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   FastAPI Server                     │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │   │
│  │  │ /embed/text │  │ /embed/batch│  │ /health     │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  │   │
│  └─────────────────────────────────────────────────────┘   │
│                            │                                │
│  ┌─────────────────────────▼───────────────────────────┐   │
│  │            Qwen3-VL-Embedding-2B Model              │   │
│  │                  (GPU 加速)                          │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 服务代码

**文件路径**: `embedding_server/main.py`（部署在 192.168.1.27）

```python
"""
Qwen3-VL-Embedding 向量化服务
部署在 192.168.1.27:8100
"""
import torch
import logging
from typing import List, Optional
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from contextlib import asynccontextmanager
from transformers import AutoModelForVision2Seq, AutoProcessor

# ================= 配置 =================
MODEL_PATH = "Qwen/Qwen3-VL-Embedding-2B"
OUTPUT_DIM = 768  # 输出向量维度
HOST = "0.0.0.0"
PORT = 8100
MAX_BATCH_SIZE = 32
MAX_TEXT_LENGTH = 32000  # 32k token 模型

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ================= 模型全局变量 =================
model = None
processor = None


def load_model():
    """加载模型"""
    global model, processor

    logger.info(f"加载 Qwen3-VL-Embedding 模型: {MODEL_PATH}")

    model = AutoModelForVision2Seq.from_pretrained(
        MODEL_PATH,
        trust_remote_code=True,
        torch_dtype=torch.float16,
        device_map="auto",
    )

    processor = AutoProcessor.from_pretrained(
        MODEL_PATH,
        trust_remote_code=True
    )

    logger.info("模型加载完成")


def unload_model():
    """卸载模型，释放显存"""
    global model, processor
    if model is not None:
        del model
        model = None
    if processor is not None:
        del processor
        processor = None
    torch.cuda.empty_cache()


@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    load_model()
    yield
    unload_model()


app = FastAPI(
    title="Qwen3-VL-Embedding Service",
    description="文本向量化服务 (发明专利检索)",
    version="1.0.0",
    lifespan=lifespan
)


# ================= 请求/响应模型 =================
class EmbedTextRequest(BaseModel):
    text: str
    instruction: Optional[str] = "Represent this patent document for retrieval"


class EmbedBatchRequest(BaseModel):
    texts: List[str]
    instruction: Optional[str] = "Represent this patent document for retrieval"


class EmbedResponse(BaseModel):
    embedding: List[float]
    dim: int


class EmbedBatchResponse(BaseModel):
    embeddings: List[List[float]]
    dim: int
    count: int


# ================= 核心向量化函数 =================
def embed_text(text: str, instruction: str = None) -> List[float]:
    """单条文本向量化"""
    global model, processor

    if model is None:
        raise RuntimeError("模型未加载")

    # 截断过长文本
    if len(text) > MAX_TEXT_LENGTH * 3:  # 粗略估计：1 token ≈ 3 字符
        text = text[:MAX_TEXT_LENGTH * 3]

    # 构建消息
    full_text = f"{instruction}: {text}" if instruction else text

    messages = [
        {
            "role": "user",
            "content": [
                {"type": "text", "text": full_text},
            ],
        }
    ]

    # 处理输入
    text_input = processor.apply_chat_template(
        messages,
        tokenize=False,
        add_generation_prompt=True
    )

    inputs = processor(
        text=[text_input],
        padding=True,
        return_tensors="pt"
    ).to(model.device)

    # 推理
    with torch.no_grad():
        outputs = model(**inputs)
        last_hidden_state = outputs.last_hidden_state

        # 取最后一个 Token 的特征
        embeddings = last_hidden_state[:, -1, :]

        # 维度截断 (Matryoshka)
        embeddings = embeddings[:, :OUTPUT_DIM]

        # L2 归一化
        embeddings = torch.nn.functional.normalize(embeddings, p=2, dim=1)

    return embeddings[0].cpu().numpy().tolist()


def embed_batch(texts: List[str], instruction: str = None) -> List[List[float]]:
    """批量文本向量化"""
    results = []
    for text in texts:
        embedding = embed_text(text, instruction)
        results.append(embedding)
    return results


# ================= API 接口 =================
@app.get("/health")
async def health_check():
    """健康检查"""
    return {
        "status": "healthy",
        "model_loaded": model is not None,
        "gpu_available": torch.cuda.is_available(),
        "gpu_name": torch.cuda.get_device_name(0) if torch.cuda.is_available() else None
    }


@app.post("/embed/text", response_model=EmbedResponse)
async def embed_text_endpoint(request: EmbedTextRequest):
    """单条文本向量化"""
    try:
        embedding = embed_text(request.text, request.instruction)
        return EmbedResponse(
            embedding=embedding,
            dim=len(embedding)
        )
    except Exception as e:
        logger.error(f"向量化失败: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/embed/batch", response_model=EmbedBatchResponse)
async def embed_batch_endpoint(request: EmbedBatchRequest):
    """批量文本向量化"""
    if len(request.texts) > MAX_BATCH_SIZE:
        raise HTTPException(
            status_code=400,
            detail=f"批量大小超限，最大 {MAX_BATCH_SIZE}"
        )

    try:
        embeddings = embed_batch(request.texts, request.instruction)
        return EmbedBatchResponse(
            embeddings=embeddings,
            dim=OUTPUT_DIM,
            count=len(embeddings)
        )
    except Exception as e:
        logger.error(f"批量向量化失败: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ================= 专利特化接口 =================
class PatentEmbedRequest(BaseModel):
    """专利向量化请求"""
    title: str
    abstract: str = ""
    claims: str = ""
    description: str = ""  # 可选，说明书很长


@app.post("/embed/patent")
async def embed_patent(request: PatentEmbedRequest):
    """
    专利多字段向量化
    返回：title_vector, abstract_vector, claims_vector, description_vector
    """
    try:
        results = {}

        # 标题向量
        if request.title:
            results["title_vector"] = embed_text(
                request.title,
                "Represent this patent title for retrieval"
            )

        # 摘要向量
        if request.abstract:
            results["abstract_vector"] = embed_text(
                request.abstract,
                "Represent this patent abstract for technical similarity search"
            )

        # 权利要求向量
        if request.claims:
            results["claims_vector"] = embed_text(
                request.claims,
                "Represent these patent claims for infringement detection"
            )

        # 说明书向量（如果提供）
        if request.description:
            results["description_vector"] = embed_text(
                request.description[:100000],  # 截断
                "Represent this patent description for retrieval"
            )

        return {
            "status": "success",
            "vectors": results,
            "dim": OUTPUT_DIM
        }
    except Exception as e:
        logger.error(f"专利向量化失败: {e}")
        raise HTTPException(status_code=500, detail=str(e))


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host=HOST, port=PORT)
```

### 3.3 部署脚本

**文件路径**: `embedding_server/start.sh`

```bash
#!/bin/bash
# 启动 Embedding 服务

cd /path/to/embedding_server

# 激活虚拟环境
source venv/bin/activate

# 设置环境变量
export CUDA_VISIBLE_DEVICES=0
export HF_HOME=/data/huggingface

# 启动服务
python -m uvicorn main:app --host 0.0.0.0 --port 8100 --workers 1

# 或者使用 gunicorn (生产环境)
# gunicorn main:app -w 1 -k uvicorn.workers.UvicornWorker -b 0.0.0.0:8100
```

### 3.4 requirements.txt

```
torch>=2.0.0
transformers>=4.40.0
accelerate>=0.27.0
fastapi>=0.109.0
uvicorn>=0.27.0
pydantic>=2.0.0
```

---

## 四、Milvus Collection 设计

### 4.1 Collection Schema

**Collection 名称**: `utility_patents`

```python
from pymilvus import CollectionSchema, FieldSchema, DataType

# 向量维度 (Qwen3-VL-Embedding 输出)
EMBEDDING_DIM = 768

utility_patent_schema = CollectionSchema(
    fields=[
        # ==================== 主键与标识 ====================
        FieldSchema(
            name="id",
            dtype=DataType.INT64,
            is_primary=True,
            auto_id=True
        ),
        FieldSchema(
            name="application_number",
            dtype=DataType.VARCHAR,
            max_length=30,
            description="申请号（业务唯一键）"
        ),
        FieldSchema(
            name="publication_number",
            dtype=DataType.VARCHAR,
            max_length=30,
            description="公开号(A1)或授权号(B2/E1)"
        ),
        FieldSchema(
            name="patent_type",
            dtype=DataType.VARCHAR,
            max_length=5,
            description="专利类型：A1/B1/B2/E1"
        ),

        # ==================== 核心文本字段 ====================
        FieldSchema(
            name="title",
            dtype=DataType.VARCHAR,
            max_length=1000,
            description="发明名称"
        ),
        FieldSchema(
            name="abstract_text",
            dtype=DataType.VARCHAR,
            max_length=8000,
            description="摘要文本"
        ),
        FieldSchema(
            name="claims_text",
            dtype=DataType.VARCHAR,
            max_length=16000,
            description="独立权利要求文本"
        ),

        # ==================== 日期字段 ====================
        FieldSchema(
            name="publication_date",
            dtype=DataType.INT64,
            description="公开/授权日期 (YYYYMMDD)"
        ),
        FieldSchema(
            name="application_date",
            dtype=DataType.INT64,
            description="申请日期 (YYYYMMDD)"
        ),

        # ==================== 当事人信息 ====================
        FieldSchema(
            name="assignee",
            dtype=DataType.VARCHAR,
            max_length=1000,
            description="专利权人名称"
        ),
        FieldSchema(
            name="assignee_country",
            dtype=DataType.VARCHAR,
            max_length=10,
            description="专利权人国家"
        ),
        FieldSchema(
            name="inventors",
            dtype=DataType.VARCHAR,
            max_length=2000,
            description="发明人列表（逗号分隔）"
        ),

        # ==================== 分类号 ====================
        FieldSchema(
            name="main_cpc",
            dtype=DataType.VARCHAR,
            max_length=30,
            description="主CPC分类号"
        ),
        FieldSchema(
            name="all_cpc_codes",
            dtype=DataType.VARCHAR,
            max_length=1000,
            description="所有CPC分类号（逗号分隔）"
        ),
        FieldSchema(
            name="main_ipc",
            dtype=DataType.VARCHAR,
            max_length=30,
            description="主IPC分类号"
        ),

        # ==================== 向量字段 ====================
        FieldSchema(
            name="title_vector",
            dtype=DataType.FLOAT_VECTOR,
            dim=EMBEDDING_DIM,
            description="发明名称向量"
        ),
        FieldSchema(
            name="abstract_vector",
            dtype=DataType.FLOAT_VECTOR,
            dim=EMBEDDING_DIM,
            description="摘要文本向量"
        ),
        FieldSchema(
            name="claims_vector",
            dtype=DataType.FLOAT_VECTOR,
            dim=EMBEDDING_DIM,
            description="权利要求向量"
        ),

        # ==================== B2/E1 特有字段 ====================
        FieldSchema(
            name="term_extension",
            dtype=DataType.INT16,
            description="专利期限延长天数"
        ),
        FieldSchema(
            name="examiner",
            dtype=DataType.VARCHAR,
            max_length=200,
            description="审查员姓名"
        ),
        FieldSchema(
            name="number_of_claims",
            dtype=DataType.INT16,
            description="权利要求数量"
        ),
        FieldSchema(
            name="related_publication",
            dtype=DataType.VARCHAR,
            max_length=30,
            description="关联公开号（B2指向A1）"
        ),

        # ==================== E1 特有字段 ====================
        FieldSchema(
            name="original_patent_number",
            dtype=DataType.VARCHAR,
            max_length=30,
            description="原始专利号（仅E1）"
        ),

        # ==================== 元数据 ====================
        FieldSchema(
            name="source_type",
            dtype=DataType.VARCHAR,
            max_length=10,
            description="来源：UTIL/REISSUE"
        ),
        FieldSchema(
            name="xml_file",
            dtype=DataType.VARCHAR,
            max_length=500,
            description="原始XML文件路径"
        ),
        FieldSchema(
            name="created_at",
            dtype=DataType.INT64,
            description="入库时间戳"
        ),
    ],
    description="发明专利 Collection（A1/B2/E1 统一存储）"
)
```

### 4.2 索引策略

```python
# 为三个向量字段创建索引
INDEX_PARAMS = {
    "index_type": "IVF_FLAT",
    "metric_type": "COSINE",
    "params": {"nlist": 256}
}

# 创建索引
collection.create_index("title_vector", INDEX_PARAMS)
collection.create_index("abstract_vector", INDEX_PARAMS)
collection.create_index("claims_vector", INDEX_PARAMS)

# 标量索引（加速过滤查询）
collection.create_index("patent_type", {"index_type": "INVERTED"})
collection.create_index("assignee_country", {"index_type": "INVERTED"})
collection.create_index("main_cpc", {"index_type": "INVERTED"})
```

---

## 五、批量导入脚本设计

### 5.1 脚本结构

```
scripts/
├── utility_patent_parser.py      # XML 解析器
├── import_utility_patents.py     # 批量导入主脚本
└── embedding_client.py           # Embedding 服务客户端
```

### 5.2 Embedding 客户端

**文件**: `scripts/embedding_client.py`

```python
"""
远程 Embedding 服务客户端
连接 192.168.1.27:8100 的 Qwen3-VL-Embedding 服务
"""
import requests
from typing import List, Dict, Optional
import logging

logger = logging.getLogger(__name__)


class EmbeddingClient:
    """Embedding 服务客户端"""

    def __init__(
        self,
        host: str = "192.168.1.27",
        port: int = 8100,
        timeout: int = 60
    ):
        self.base_url = f"http://{host}:{port}"
        self.timeout = timeout

    def health_check(self) -> bool:
        """健康检查"""
        try:
            resp = requests.get(
                f"{self.base_url}/health",
                timeout=10
            )
            return resp.status_code == 200
        except Exception as e:
            logger.error(f"健康检查失败: {e}")
            return False

    def embed_text(
        self,
        text: str,
        instruction: Optional[str] = None
    ) -> List[float]:
        """单条文本向量化"""
        payload = {"text": text}
        if instruction:
            payload["instruction"] = instruction

        resp = requests.post(
            f"{self.base_url}/embed/text",
            json=payload,
            timeout=self.timeout
        )
        resp.raise_for_status()
        return resp.json()["embedding"]

    def embed_batch(
        self,
        texts: List[str],
        instruction: Optional[str] = None
    ) -> List[List[float]]:
        """批量文本向量化"""
        payload = {"texts": texts}
        if instruction:
            payload["instruction"] = instruction

        resp = requests.post(
            f"{self.base_url}/embed/batch",
            json=payload,
            timeout=self.timeout * 2
        )
        resp.raise_for_status()
        return resp.json()["embeddings"]

    def embed_patent(
        self,
        title: str,
        abstract: str = "",
        claims: str = "",
        description: str = ""
    ) -> Dict[str, List[float]]:
        """专利多字段向量化"""
        payload = {
            "title": title,
            "abstract": abstract,
            "claims": claims,
            "description": description
        }

        resp = requests.post(
            f"{self.base_url}/embed/patent",
            json=payload,
            timeout=self.timeout * 3
        )
        resp.raise_for_status()
        return resp.json()["vectors"]


# 全局客户端实例
embedding_client = EmbeddingClient()
```

### 5.3 XML 解析器

**文件**: `scripts/utility_patent_parser.py`

```python
"""
发明专利 XML 解析器
支持 A1（申请公开）、B2（授权专利）、E1（再颁专利）
"""
import os
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from typing import Optional, List, Generator
from pathlib import Path
import logging

logger = logging.getLogger(__name__)


@dataclass
class UtilityPatent:
    """发明专利数据结构"""
    # 基础标识
    application_number: str
    publication_number: str
    patent_type: str  # A1/B1/B2/E1

    # 核心文本
    title: str
    abstract: str
    claims: str  # 合并的权利要求文本
    independent_claims: List[str]  # 独立权利要求列表

    # 日期
    publication_date: int  # YYYYMMDD
    application_date: int

    # 当事人
    assignee: str
    assignee_country: str
    inventors: List[str]

    # 分类号
    main_cpc: str
    all_cpc_codes: List[str]
    main_ipc: str
    all_ipc_codes: List[str]

    # B2/E1 特有
    term_extension: int = 0
    examiner: str = ""
    number_of_claims: int = 0
    related_publication: str = ""

    # E1 特有
    original_patent_number: str = ""
    original_application_number: str = ""

    # 元数据
    source_type: str = ""  # UTIL/REISSUE
    xml_file: str = ""
    data_dir: str = ""


def parse_date(date_str: str) -> int:
    """解析日期字符串为整数 YYYYMMDD"""
    if date_str and len(date_str) >= 8:
        try:
            return int(date_str[:8])
        except ValueError:
            pass
    return 0


def extract_text(element) -> str:
    """提取元素的所有文本内容"""
    if element is None:
        return ""
    return ''.join(element.itertext()).strip()


def parse_utility_patent_xml(xml_path: str) -> Optional[UtilityPatent]:
    """
    解析发明专利 XML 文件
    自动识别 A1/B2/E1 类型
    """
    try:
        tree = ET.parse(xml_path)
        root = tree.getroot()
        root_tag = root.tag

        # 确定专利类型和书目数据节点
        if root_tag == 'us-patent-application':
            patent_type = 'A1'
            biblio = root.find('us-bibliographic-data-application')
        elif root_tag == 'us-patent-grant':
            biblio = root.find('us-bibliographic-data-grant')

            # 根据 appl-type 区分 B2 和 E1
            app_ref = biblio.find('application-reference')
            appl_type = app_ref.get('appl-type', '') if app_ref is not None else ''

            if appl_type == 'reissue':
                patent_type = 'E1'
            else:
                # 从 kind code 获取 B1 或 B2
                kind = biblio.findtext('.//publication-reference/document-id/kind', 'B2')
                patent_type = kind
        else:
            logger.warning(f"未知的根节点: {root_tag}")
            return None

        if biblio is None:
            logger.warning(f"未找到书目数据节点: {xml_path}")
            return None

        # ============ 解析公共字段 ============
        # 公开/授权号
        pub_ref = biblio.find('.//publication-reference/document-id')
        publication_number = pub_ref.findtext('doc-number', '') if pub_ref else ''
        publication_date = parse_date(pub_ref.findtext('date', '')) if pub_ref else 0

        # 申请号
        app_ref = biblio.find('.//application-reference/document-id')
        application_number = app_ref.findtext('doc-number', '') if app_ref else ''
        application_date = parse_date(app_ref.findtext('date', '')) if app_ref else 0

        # 发明名称
        title = biblio.findtext('invention-title', '')

        # 摘要
        abstract_elem = root.find('.//abstract')
        abstract = extract_text(abstract_elem)

        # 权利要求
        claims_list = []
        independent_claims = []
        for claim in root.findall('.//claim'):
            claim_text = extract_text(claim)
            claims_list.append(claim_text)
            # 独立权利要求通常不包含 "according to claim" 等引用语
            if 'according to claim' not in claim_text.lower() and 'as claimed in claim' not in claim_text.lower():
                independent_claims.append(claim_text)

        claims = '\n'.join(claims_list)

        # 专利权人
        assignee_elem = biblio.find('.//assignee')
        assignee = ''
        assignee_country = ''
        if assignee_elem is not None:
            assignee = assignee_elem.findtext('.//orgname', '')
            if not assignee:
                # 个人申请人
                first = assignee_elem.findtext('.//first-name', '')
                last = assignee_elem.findtext('.//last-name', '')
                assignee = f"{first} {last}".strip()
            addr = assignee_elem.find('.//address')
            if addr is not None:
                assignee_country = addr.findtext('country', '')

        # 发明人
        inventors = []
        for inventor in biblio.findall('.//inventor'):
            first = inventor.findtext('.//first-name', '')
            last = inventor.findtext('.//last-name', '')
            name = f"{first} {last}".strip()
            if name:
                inventors.append(name)

        # CPC 分类号
        cpc_codes = []
        for cpc in biblio.findall('.//classification-cpc'):
            section = cpc.findtext('section', '')
            cls = cpc.findtext('class', '')
            subclass = cpc.findtext('subclass', '')
            main_group = cpc.findtext('main-group', '')
            subgroup = cpc.findtext('subgroup', '')
            cpc_code = f"{section}{cls}{subclass}{main_group}/{subgroup}"
            if cpc_code.strip('/'):
                cpc_codes.append(cpc_code)

        main_cpc = cpc_codes[0] if cpc_codes else ''

        # IPC 分类号
        ipc_codes = []
        for ipc in biblio.findall('.//classification-ipcr'):
            section = ipc.findtext('section', '')
            cls = ipc.findtext('class', '')
            subclass = ipc.findtext('subclass', '')
            main_group = ipc.findtext('main-group', '')
            subgroup = ipc.findtext('subgroup', '')
            ipc_code = f"{section}{cls}{subclass}{main_group}/{subgroup}"
            if ipc_code.strip('/'):
                ipc_codes.append(ipc_code)

        main_ipc = ipc_codes[0] if ipc_codes else ''

        # ============ 解析 B2/E1 特有字段 ============
        term_extension = 0
        examiner = ''
        number_of_claims = 0
        related_publication = ''
        original_patent_number = ''
        original_application_number = ''

        if patent_type in ('B1', 'B2', 'E1'):
            # 专利期限延长
            term = biblio.find('.//us-term-of-grant/us-term-extension')
            if term is not None and term.text:
                try:
                    term_extension = int(term.text)
                except ValueError:
                    pass

            # 审查员
            exam = biblio.find('.//primary-examiner')
            if exam is not None:
                first = exam.findtext('first-name', '')
                last = exam.findtext('last-name', '')
                examiner = f"{first} {last}".strip()

            # 权利要求数量
            num_claims = biblio.findtext('number-of-claims', '0')
            try:
                number_of_claims = int(num_claims)
            except ValueError:
                pass

            # 关联公开号 (B2 -> A1)
            related = biblio.find('.//us-related-documents/related-publication/document-id/doc-number')
            if related is not None:
                related_publication = related.text or ''

        # ============ E1 特有字段 ============
        if patent_type == 'E1':
            reissue = biblio.find('.//us-related-documents/reissue')
            if reissue is not None:
                orig_app = reissue.find('.//parent-doc/document-id/doc-number')
                if orig_app is not None:
                    original_application_number = orig_app.text or ''

                orig_patent = reissue.find('.//parent-grant-document/document-id/doc-number')
                if orig_patent is not None:
                    original_patent_number = orig_patent.text or ''

        return UtilityPatent(
            application_number=application_number,
            publication_number=publication_number,
            patent_type=patent_type,
            title=title,
            abstract=abstract,
            claims=claims,
            independent_claims=independent_claims,
            publication_date=publication_date,
            application_date=application_date,
            assignee=assignee,
            assignee_country=assignee_country,
            inventors=inventors,
            main_cpc=main_cpc,
            all_cpc_codes=cpc_codes,
            main_ipc=main_ipc,
            all_ipc_codes=ipc_codes,
            term_extension=term_extension,
            examiner=examiner,
            number_of_claims=number_of_claims,
            related_publication=related_publication,
            original_patent_number=original_patent_number,
            original_application_number=original_application_number,
            xml_file=xml_path
        )

    except ET.ParseError as e:
        logger.error(f"XML 解析错误 {xml_path}: {e}")
        return None
    except Exception as e:
        logger.error(f"解析异常 {xml_path}: {e}")
        return None


def scan_all_utility_patents(
    data_dir: str,
    source_types: List[str] = ['UTIL', 'REISSUE']
) -> Generator[UtilityPatent, None, None]:
    """
    扫描所有发明专利（生成器模式）

    目录结构:
    D:\data\I日期\I日期\UTIL\专利号\专利号\*.XML
    D:\data\I日期\I日期\REISSUE\专利号\专利号\*.XML

    排除规则:
    - 后缀为 -SUPP 的目录
    - DESIGN 目录
    """
    data_path = Path(data_dir)

    for date_dir in data_path.iterdir():
        if not date_dir.is_dir():
            continue

        # 排除 -SUPP 目录
        if date_dir.name.endswith('-SUPP'):
            logger.debug(f"跳过 SUPP 目录: {date_dir.name}")
            continue

        # 内层同名目录
        inner_dir = date_dir / date_dir.name
        if not inner_dir.exists():
            continue

        for source_type in source_types:
            type_dir = inner_dir / source_type
            if not type_dir.exists():
                continue

            logger.info(f"扫描目录: {type_dir}")

            # 遍历专利目录 (专利号\专利号\*.XML)
            for patent_dir_1 in type_dir.iterdir():
                if not patent_dir_1.is_dir():
                    continue

                patent_dir_2 = patent_dir_1 / patent_dir_1.name
                if not patent_dir_2.exists():
                    patent_dir_2 = patent_dir_1  # 兼容单层目录

                # 查找 XML 文件
                xml_files = list(patent_dir_2.glob('*.XML')) + list(patent_dir_2.glob('*.xml'))

                for xml_file in xml_files:
                    patent = parse_utility_patent_xml(str(xml_file))
                    if patent:
                        patent.source_type = source_type
                        patent.data_dir = str(patent_dir_2)
                        yield patent
```

### 5.4 批量导入主脚本

**文件**: `scripts/import_utility_patents.py`

```python
"""
发明专利批量导入脚本
1. 扫描 D:\data 下的 UTIL 和 REISSUE 目录
2. 解析 XML 元数据
3. 调用远程 Embedding 服务向量化
4. 存入 Milvus (utility_patents)
"""
import os
import sys
import gc
import time
import logging
import argparse
from pathlib import Path
from datetime import datetime
from typing import List, Dict

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from pymilvus import (
    connections, Collection, FieldSchema, CollectionSchema, DataType, utility
)
from app.config import MILVUS_HOST, MILVUS_PORT

from utility_patent_parser import scan_all_utility_patents, UtilityPatent
from embedding_client import embedding_client

# ================= 配置 =================
COLLECTION_NAME = "utility_patents"
EMBEDDING_DIM = 768
INSERT_BATCH_SIZE = 8  # 批量插入大小
MAX_VARCHAR_LEN = 8000
GC_INTERVAL = 50

# 去重优先级
PRIORITY = {'A1': 1, 'B1': 2, 'B2': 3, 'E1': 4}

INDEX_PARAMS = {
    "index_type": "IVF_FLAT",
    "metric_type": "COSINE",
    "params": {"nlist": 256}
}

# 日志配置
LOG_DIR = Path(__file__).parent
LOG_FILE = LOG_DIR / f"import_utility_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILE, encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


def connect_milvus():
    """连接 Milvus"""
    logger.info(f"连接 Milvus: {MILVUS_HOST}:{MILVUS_PORT}")
    connections.connect(alias="default", host=MILVUS_HOST, port=MILVUS_PORT)
    logger.info("Milvus 连接成功")


def create_collection() -> Collection:
    """创建 Collection"""
    logger.info(f"创建 collection '{COLLECTION_NAME}'...")

    if utility.has_collection(COLLECTION_NAME):
        logger.warning("Collection 已存在，将删除重建")
        utility.drop_collection(COLLECTION_NAME)

    fields = [
        FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
        FieldSchema(name="application_number", dtype=DataType.VARCHAR, max_length=30),
        FieldSchema(name="publication_number", dtype=DataType.VARCHAR, max_length=30),
        FieldSchema(name="patent_type", dtype=DataType.VARCHAR, max_length=5),
        FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=1000),
        FieldSchema(name="abstract_text", dtype=DataType.VARCHAR, max_length=MAX_VARCHAR_LEN),
        FieldSchema(name="claims_text", dtype=DataType.VARCHAR, max_length=16000),
        FieldSchema(name="publication_date", dtype=DataType.INT64),
        FieldSchema(name="application_date", dtype=DataType.INT64),
        FieldSchema(name="assignee", dtype=DataType.VARCHAR, max_length=1000),
        FieldSchema(name="assignee_country", dtype=DataType.VARCHAR, max_length=10),
        FieldSchema(name="inventors", dtype=DataType.VARCHAR, max_length=2000),
        FieldSchema(name="main_cpc", dtype=DataType.VARCHAR, max_length=30),
        FieldSchema(name="all_cpc_codes", dtype=DataType.VARCHAR, max_length=1000),
        FieldSchema(name="main_ipc", dtype=DataType.VARCHAR, max_length=30),
        FieldSchema(name="title_vector", dtype=DataType.FLOAT_VECTOR, dim=EMBEDDING_DIM),
        FieldSchema(name="abstract_vector", dtype=DataType.FLOAT_VECTOR, dim=EMBEDDING_DIM),
        FieldSchema(name="claims_vector", dtype=DataType.FLOAT_VECTOR, dim=EMBEDDING_DIM),
        FieldSchema(name="term_extension", dtype=DataType.INT16),
        FieldSchema(name="examiner", dtype=DataType.VARCHAR, max_length=200),
        FieldSchema(name="number_of_claims", dtype=DataType.INT16),
        FieldSchema(name="related_publication", dtype=DataType.VARCHAR, max_length=30),
        FieldSchema(name="original_patent_number", dtype=DataType.VARCHAR, max_length=30),
        FieldSchema(name="source_type", dtype=DataType.VARCHAR, max_length=10),
        FieldSchema(name="xml_file", dtype=DataType.VARCHAR, max_length=500),
        FieldSchema(name="created_at", dtype=DataType.INT64),
    ]

    schema = CollectionSchema(fields, description="Utility Patents (A1/B2/E1)")
    collection = Collection(name=COLLECTION_NAME, schema=schema)

    # 创建向量索引
    logger.info("创建向量索引...")
    collection.create_index("title_vector", INDEX_PARAMS)
    collection.create_index("abstract_vector", INDEX_PARAMS)
    collection.create_index("claims_vector", INDEX_PARAMS)

    logger.info("Collection 创建完成")
    return collection


def get_existing_patents(collection: Collection) -> Dict[str, str]:
    """获取已存在的专利（申请号 -> 专利类型）"""
    existing = {}
    last_id = -1

    try:
        while True:
            results = collection.query(
                expr=f'id > {last_id}',
                output_fields=['id', 'application_number', 'patent_type'],
                limit=1000
            )
            if not results:
                break
            for r in results:
                existing[r['application_number']] = r['patent_type']
            last_id = max(r['id'] for r in results)

        logger.info(f"已存在 {len(existing)} 条专利记录")
    except Exception as e:
        logger.error(f"查询已存在记录失败: {e}")

    return existing


def should_update(new_type: str, existing_type: str) -> bool:
    """判断是否应该更新（新类型优先级更高）"""
    return PRIORITY.get(new_type, 0) > PRIORITY.get(existing_type, 0)


def truncate_str(s, max_len: int) -> str:
    """安全截断字符串"""
    if s is None:
        return ""
    s = str(s)
    return s[:max_len] if len(s) > max_len else s


def vectorize_patent(patent: UtilityPatent) -> Dict[str, List[float]]:
    """调用远程 Embedding 服务向量化专利"""
    try:
        vectors = embedding_client.embed_patent(
            title=patent.title,
            abstract=patent.abstract,
            claims='\n'.join(patent.independent_claims[:3])  # 取前3个独立权利要求
        )
        return vectors
    except Exception as e:
        logger.error(f"向量化失败 {patent.publication_number}: {e}")
        raise


def insert_batch(collection: Collection, batch_data: List[Dict]) -> bool:
    """批量插入数据"""
    try:
        entities = [
            [d["application_number"] for d in batch_data],
            [d["publication_number"] for d in batch_data],
            [d["patent_type"] for d in batch_data],
            [d["title"] for d in batch_data],
            [d["abstract_text"] for d in batch_data],
            [d["claims_text"] for d in batch_data],
            [d["publication_date"] for d in batch_data],
            [d["application_date"] for d in batch_data],
            [d["assignee"] for d in batch_data],
            [d["assignee_country"] for d in batch_data],
            [d["inventors"] for d in batch_data],
            [d["main_cpc"] for d in batch_data],
            [d["all_cpc_codes"] for d in batch_data],
            [d["main_ipc"] for d in batch_data],
            [d["title_vector"] for d in batch_data],
            [d["abstract_vector"] for d in batch_data],
            [d["claims_vector"] for d in batch_data],
            [d["term_extension"] for d in batch_data],
            [d["examiner"] for d in batch_data],
            [d["number_of_claims"] for d in batch_data],
            [d["related_publication"] for d in batch_data],
            [d["original_patent_number"] for d in batch_data],
            [d["source_type"] for d in batch_data],
            [d["xml_file"] for d in batch_data],
            [d["created_at"] for d in batch_data],
        ]
        collection.insert(entities)
        logger.info(f"  插入 {len(batch_data)} 条记录")
        return True
    except Exception as e:
        logger.error(f"批量插入失败: {e}")
        return False


def main():
    parser = argparse.ArgumentParser(description='发明专利批量导入')
    parser.add_argument('--data-dir', default=r'D:\data', help='数据根目录')
    parser.add_argument('--append', action='store_true', help='追加模式')
    parser.add_argument('--source', nargs='+', default=['UTIL', 'REISSUE'],
                        help='数据来源类型')
    args = parser.parse_args()

    logger.info("=" * 60)
    logger.info("发明专利批量导入 (Qwen3-VL-Embedding + Milvus)")
    logger.info(f"数据目录: {args.data_dir}")
    logger.info(f"数据来源: {args.source}")
    logger.info(f"日志文件: {LOG_FILE}")
    logger.info("=" * 60)

    # 检查 Embedding 服务
    logger.info("检查 Embedding 服务...")
    if not embedding_client.health_check():
        logger.error("Embedding 服务不可用，请检查 192.168.1.27:8100")
        return
    logger.info("Embedding 服务正常")

    # 连接 Milvus
    connect_milvus()

    # 创建或获取 Collection
    if args.append and utility.has_collection(COLLECTION_NAME):
        logger.info(f"追加模式，使用现有 collection")
        collection = Collection(name=COLLECTION_NAME)
    else:
        collection = create_collection()
    collection.load()

    # 获取已存在记录
    existing = get_existing_patents(collection) if args.append else {}

    # 扫描专利
    logger.info("开始扫描发明专利...")
    patent_generator = scan_all_utility_patents(args.data_dir, args.source)

    # 统计
    start_time = time.time()
    success_count = 0
    skip_count = 0
    fail_count = 0
    update_count = 0
    batch_data = []
    processed = 0

    for patent in patent_generator:
        processed += 1

        # 检查去重
        if patent.application_number in existing:
            existing_type = existing[patent.application_number]
            if not should_update(patent.patent_type, existing_type):
                logger.debug(f"跳过: {patent.publication_number} (已有 {existing_type})")
                skip_count += 1
                continue
            else:
                # 删除旧版本
                collection.delete(f'application_number == "{patent.application_number}"')
                logger.info(f"更新: {patent.publication_number} ({existing_type} -> {patent.patent_type})")
                update_count += 1

        try:
            # 向量化
            vectors = vectorize_patent(patent)

            # 准备数据
            data = {
                "application_number": truncate_str(patent.application_number, 30),
                "publication_number": truncate_str(patent.publication_number, 30),
                "patent_type": patent.patent_type,
                "title": truncate_str(patent.title, 1000),
                "abstract_text": truncate_str(patent.abstract, MAX_VARCHAR_LEN),
                "claims_text": truncate_str(patent.claims, 16000),
                "publication_date": patent.publication_date,
                "application_date": patent.application_date,
                "assignee": truncate_str(patent.assignee, 1000),
                "assignee_country": truncate_str(patent.assignee_country, 10),
                "inventors": truncate_str(','.join(patent.inventors), 2000),
                "main_cpc": truncate_str(patent.main_cpc, 30),
                "all_cpc_codes": truncate_str(','.join(patent.all_cpc_codes), 1000),
                "main_ipc": truncate_str(patent.main_ipc, 30),
                "title_vector": vectors.get("title_vector", [0.0] * EMBEDDING_DIM),
                "abstract_vector": vectors.get("abstract_vector", [0.0] * EMBEDDING_DIM),
                "claims_vector": vectors.get("claims_vector", [0.0] * EMBEDDING_DIM),
                "term_extension": patent.term_extension,
                "examiner": truncate_str(patent.examiner, 200),
                "number_of_claims": patent.number_of_claims,
                "related_publication": truncate_str(patent.related_publication, 30),
                "original_patent_number": truncate_str(patent.original_patent_number, 30),
                "source_type": patent.source_type,
                "xml_file": truncate_str(patent.xml_file, 500),
                "created_at": int(time.time()),
            }

            batch_data.append(data)
            success_count += 1

            # 批量插入
            if len(batch_data) >= INSERT_BATCH_SIZE:
                insert_batch(collection, batch_data)
                batch_data = []

            # 内存清理
            if processed % GC_INTERVAL == 0:
                gc.collect()
                logger.info(f"进度: {processed} | 成功: {success_count} | 跳过: {skip_count} | 更新: {update_count}")

        except Exception as e:
            logger.error(f"处理失败 {patent.publication_number}: {e}")
            fail_count += 1

    # 插入剩余数据
    if batch_data:
        insert_batch(collection, batch_data)

    # 完成
    collection.flush()
    total_time = time.time() - start_time

    logger.info("=" * 60)
    logger.info("导入完成!")
    logger.info(f"成功: {success_count}")
    logger.info(f"更新: {update_count}")
    logger.info(f"跳过: {skip_count}")
    logger.info(f"失败: {fail_count}")
    logger.info(f"总记录: {collection.num_entities}")
    logger.info(f"耗时: {total_time/60:.1f} 分钟")
    logger.info("=" * 60)


if __name__ == "__main__":
    main()
```

---

## 六、前端设计

### 6.1 新增页面

**页面路径**: `web/dinov2TestWeb/src/views/UtilityPatentPage.vue`

### 6.2 界面布局

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        发明专利检索系统                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ 产品名称:  [                                                  ]  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ 产品描述:                                                        │   │
│  │ [                                                              ] │   │
│  │ [                                                              ] │   │
│  │ [                                                              ] │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐           │
│  │ 搜索向量: [v]  │  │ 结果数量: [20] │  │ 相似度阈值:    │           │
│  │ ○ 标题        │  │                │  │ [    0.5    ]  │           │
│  │ ○ 摘要        │  │                │  │                │           │
│  │ ○ 权利要求    │  │                │  │                │           │
│  └────────────────┘  └────────────────┘  └────────────────┘           │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        [ 🔍 开始检索 ]                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│  搜索结果 (共 20 条)                              耗时: 0.35s          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ #1  US12345678B2                                    相似度: 0.92 │   │
│  │ ──────────────────────────────────────────────────────────────── │   │
│  │ 发明名称: Method and System for Image Recognition...             │   │
│  │ 专利权人: GOOGLE LLC (US)                                        │   │
│  │ 发明人:   John Smith, Jane Doe                                   │   │
│  │ 申请日:   2023-05-15   |   授权日:   2025-01-10                  │   │
│  │ CPC分类:  G06V10/82                                              │   │
│  │ ──────────────────────────────────────────────────────────────── │   │
│  │ 摘要:                                                            │   │
│  │ A method for processing images using deep learning techniques... │   │
│  │                                                    [ 查看详情 ]  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ #2  US20241234567A1                                 相似度: 0.88 │   │
│  │ ...                                                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 6.3 搜索参数说明

| 参数 | 说明 | 默认值 |
|------|------|--------|
| 产品名称 | 用户的产品/技术名称 | - |
| 产品描述 | 产品功能、技术特点的详细描述 | - |
| 搜索向量 | 使用哪个向量字段进行搜索 | 摘要 |
| 结果数量 | 返回的专利数量 (Top-K) | 20 |
| 相似度阈值 | 最低相似度分数过滤 | 0.5 |

### 6.4 搜索逻辑

1. **输入处理**：将「产品名称 + 产品描述」拼接成查询文本
2. **向量化**：调用 Embedding 服务生成查询向量
3. **向量搜索**：在 Milvus 中搜索相似专利
4. **结果过滤**：按相似度阈值过滤
5. **结果展示**：按相似度排序展示

---

## 七、后端 API 设计

### 7.1 新增接口

**文件**: `app/api/search_utility.py`

```python
"""
发明专利搜索 API
"""
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import List, Optional
import time
import logging

from app.services.utility_patent_service import utility_patent_service

router = APIRouter(prefix="/api/utility", tags=["发明专利"])
logger = logging.getLogger(__name__)


class SearchRequest(BaseModel):
    """搜索请求"""
    product_name: str
    product_description: str = ""
    search_field: str = "abstract"  # title / abstract / claims
    top_k: int = 20
    min_score: float = 0.5
    filters: Optional[dict] = None  # 过滤条件


class PatentResult(BaseModel):
    """专利结果"""
    publication_number: str
    patent_type: str
    title: str
    abstract: str
    assignee: str
    assignee_country: str
    inventors: str
    application_date: int
    publication_date: int
    main_cpc: str
    score: float


class SearchResponse(BaseModel):
    """搜索响应"""
    results: List[PatentResult]
    total: int
    search_time: float
    embed_time: float


@router.post("/search", response_model=SearchResponse)
async def search_utility_patents(request: SearchRequest):
    """
    搜索发明专利

    - product_name: 产品名称
    - product_description: 产品描述
    - search_field: 搜索字段 (title/abstract/claims)
    - top_k: 返回数量
    - min_score: 最低相似度
    """
    try:
        start_time = time.time()

        # 拼接查询文本
        query_text = f"{request.product_name}. {request.product_description}"

        # 搜索
        results, embed_time = await utility_patent_service.search(
            query_text=query_text,
            search_field=request.search_field,
            top_k=request.top_k,
            min_score=request.min_score,
            filters=request.filters
        )

        search_time = time.time() - start_time

        return SearchResponse(
            results=results,
            total=len(results),
            search_time=search_time,
            embed_time=embed_time
        )

    except Exception as e:
        logger.error(f"搜索失败: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/stats")
async def get_stats():
    """获取 Collection 统计信息"""
    try:
        stats = utility_patent_service.get_stats()
        return stats
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

### 7.2 服务层

**文件**: `app/services/utility_patent_service.py`

```python
"""
发明专利服务
"""
import time
import logging
import requests
from typing import List, Tuple, Optional
from pymilvus import Collection, connections

from app.config import MILVUS_HOST, MILVUS_PORT

logger = logging.getLogger(__name__)

COLLECTION_NAME = "utility_patents"
EMBEDDING_SERVICE_URL = "http://192.168.1.27:8100"


class UtilityPatentService:
    """发明专利服务"""

    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if self._initialized:
            return
        self.collection = None
        self._initialized = True

    def connect(self):
        """连接 Milvus"""
        if self.collection is not None:
            return

        connections.connect(host=MILVUS_HOST, port=MILVUS_PORT)
        self.collection = Collection(COLLECTION_NAME)
        self.collection.load()
        logger.info(f"已连接 {COLLECTION_NAME}")

    def _get_embedding(self, text: str, instruction: str) -> List[float]:
        """调用远程 Embedding 服务"""
        resp = requests.post(
            f"{EMBEDDING_SERVICE_URL}/embed/text",
            json={"text": text, "instruction": instruction},
            timeout=60
        )
        resp.raise_for_status()
        return resp.json()["embedding"]

    async def search(
        self,
        query_text: str,
        search_field: str = "abstract",
        top_k: int = 20,
        min_score: float = 0.5,
        filters: Optional[dict] = None
    ) -> Tuple[List[dict], float]:
        """
        搜索发明专利

        Returns:
            (results, embed_time)
        """
        self.connect()

        # 选择向量字段和指令
        field_config = {
            "title": ("title_vector", "Represent this query for patent title search"),
            "abstract": ("abstract_vector", "Represent this query for patent abstract search"),
            "claims": ("claims_vector", "Represent this query for patent claims search"),
        }

        vector_field, instruction = field_config.get(
            search_field,
            field_config["abstract"]
        )

        # 向量化查询
        embed_start = time.time()
        query_vector = self._get_embedding(query_text, instruction)
        embed_time = time.time() - embed_start

        # 构建过滤表达式
        expr = ""
        if filters:
            conditions = []
            if "patent_type" in filters:
                conditions.append(f'patent_type == "{filters["patent_type"]}"')
            if "assignee_country" in filters:
                conditions.append(f'assignee_country == "{filters["assignee_country"]}"')
            if "main_cpc" in filters:
                conditions.append(f'main_cpc like "{filters["main_cpc"]}%"')
            expr = " and ".join(conditions)

        # 搜索
        search_params = {"metric_type": "COSINE", "params": {"nprobe": 32}}

        results = self.collection.search(
            data=[query_vector],
            anns_field=vector_field,
            param=search_params,
            limit=top_k,
            expr=expr if expr else None,
            output_fields=[
                "publication_number", "patent_type", "title", "abstract_text",
                "assignee", "assignee_country", "inventors",
                "application_date", "publication_date", "main_cpc"
            ]
        )

        # 格式化结果
        formatted = []
        for hit in results[0]:
            if hit.score < min_score:
                continue

            formatted.append({
                "publication_number": hit.entity.get("publication_number"),
                "patent_type": hit.entity.get("patent_type"),
                "title": hit.entity.get("title"),
                "abstract": hit.entity.get("abstract_text", "")[:500],
                "assignee": hit.entity.get("assignee"),
                "assignee_country": hit.entity.get("assignee_country"),
                "inventors": hit.entity.get("inventors"),
                "application_date": hit.entity.get("application_date"),
                "publication_date": hit.entity.get("publication_date"),
                "main_cpc": hit.entity.get("main_cpc"),
                "score": round(hit.score, 4)
            })

        return formatted, embed_time

    def get_stats(self) -> dict:
        """获取统计信息"""
        self.connect()
        return {
            "collection": COLLECTION_NAME,
            "total_count": self.collection.num_entities,
            "embedding_dim": 768
        }


# 全局服务实例
utility_patent_service = UtilityPatentService()
```

---

## 八、部署清单

### 8.1 192.168.1.27 (GPU 服务器)

| 组件 | 端口 | 说明 |
|------|------|------|
| Embedding Service | 8100 | Qwen3-VL-Embedding HTTP 服务 |

**部署步骤**：
```bash
# 1. 创建目录
mkdir -p /opt/embedding_server
cd /opt/embedding_server

# 2. 上传代码 (main.py, requirements.txt, start.sh)

# 3. 创建虚拟环境
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt

# 4. 下载模型
export HF_HOME=/data/huggingface
python -c "from transformers import AutoModelForVision2Seq; AutoModelForVision2Seq.from_pretrained('Qwen/Qwen3-VL-Embedding-2B')"

# 5. 启动服务
chmod +x start.sh
./start.sh
```

### 8.2 192.168.1.174 (当前机器)

| 组件 | 端口 | 说明 |
|------|------|------|
| FastAPI 后端 | 8000 | 主 API 服务 |
| Vue 前端 | 5173 | 开发服务器 |
| Milvus | 31278 | 向量数据库 |
| MinIO | 9000 | 对象存储 |

**新增文件**：
```
scripts/
├── utility_patent_parser.py      # XML 解析器
├── embedding_client.py           # Embedding 客户端
└── import_utility_patents.py     # 批量导入脚本

app/
├── api/
│   └── search_utility.py         # 搜索 API
└── services/
    └── utility_patent_service.py # 服务层

web/dinov2TestWeb/src/
├── views/
│   └── UtilityPatentPage.vue     # 前端页面
└── api/
    └── utility.js                # API 调用
```

---

## 九、执行流程

### 9.1 批量导入流程

```
1. 启动 192.168.1.27 的 Embedding 服务
   $ ./start.sh

2. 在 192.168.1.174 执行导入脚本
   $ cd D:\dev\develop\dinov2_milvus_Test
   $ python scripts/import_utility_patents.py --data-dir D:\data

3. 监控日志
   $ tail -f scripts/import_utility_*.log
```

### 9.2 检索流程

```
用户输入
    │
    ▼
┌─────────────────┐
│ 产品名称+描述    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 后端 API        │
│ /api/utility/   │
│ search          │
└────────┬────────┘
         │
         ▼
┌─────────────────┐     HTTP      ┌─────────────────┐
│ 调用 Embedding  │ ──────────▶  │ 192.168.1.27    │
│ 服务            │ ◀──────────  │ :8100           │
└────────┬────────┘   向量        └─────────────────┘
         │
         ▼
┌─────────────────┐
│ Milvus 向量搜索  │
│ utility_patents │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 返回 Top-K 结果  │
└─────────────────┘
```

---

## 十、总结

### 10.1 系统特点

1. **分布式架构**：Embedding 服务部署在 GPU 服务器，API 服务和数据库在主服务器
2. **多向量检索**：支持标题、摘要、权利要求三个维度的语义搜索
3. **智能去重**：E1 > B2 > A1 优先级，保留最有法律效力的版本
4. **增量导入**：支持追加模式，自动跳过已导入的专利

### 10.2 关键配置

| 配置项 | 值 |
|--------|-----|
| Embedding 模型 | Qwen3-VL-Embedding-2B |
| 向量维度 | 768 |
| Milvus Collection | utility_patents |
| 索引类型 | IVF_FLAT + COSINE |
| 数据来源 | D:\data\*\*\UTIL, REISSUE |

### 10.3 预估性能

| 指标 | 预估值 |
|------|--------|
| 单条向量化 | ~0.5s |
| 批量导入速度 | ~100 条/分钟 |
| 搜索延迟 | < 500ms |
| 存储空间 | ~1KB/专利 (向量) |
